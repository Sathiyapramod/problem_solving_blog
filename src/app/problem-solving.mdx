# Problem Solving ðŸ§©

Learn systematic approaches to tackle complex programming problems and develop your problem-solving skills.

## Table of Contents

- [Problem-Solving Framework](#problem-solving-framework)
- [Common Problem Types](#common-problem-types)
- [Problem-Solving Strategies](#problem-solving-strategies)
- [Practice Problems](#practice-problems)
- [Tips and Best Practices](#tips-and-best-practices)

## Problem-Solving Framework

### 1. Understand the Problem

- Read the problem statement carefully
- Identify inputs and outputs
- Clarify any ambiguities
- Ask questions if needed

### 2. Plan Your Approach

- Break down the problem into smaller parts
- Consider different algorithms and data structures
- Think about edge cases
- Estimate time and space complexity

### 3. Implement the Solution

- Write clean, readable code
- Use meaningful variable names
- Add comments for complex logic
- Test with simple cases first

### 4. Test and Debug

- Test with edge cases
- Verify time and space complexity
- Look for potential optimizations
- Refactor if necessary

## Common Problem Types

### Array Problems

```python
# Example: Find the maximum subarray sum
def max_subarray_sum(arr):
    max_sum = float('-inf')
    current_sum = 0

    for num in arr:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum

# Time Complexity: O(n)
# Space Complexity: O(1)
```

### String Problems

```python
# Example: Check if string is palindrome
def is_palindrome(s):
    # Remove non-alphanumeric characters and convert to lowercase
    s = ''.join(c.lower() for c in s if c.isalnum())
    return s == s[::-1]

# Time Complexity: O(n)
# Space Complexity: O(n)
```

### Tree Problems

```python
# Example: Maximum depth of binary tree
def max_depth(root):
    if not root:
        return 0

    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)

    return max(left_depth, right_depth) + 1

# Time Complexity: O(n)
# Space Complexity: O(h) where h is height of tree
```

### Graph Problems

```python
# Example: Number of islands
def num_islands(grid):
    if not grid:
        return 0

    def dfs(i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
            return

        grid[i][j] = '0'
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1

    return count

# Time Complexity: O(m * n)
# Space Complexity: O(m * n)
```

## Problem-Solving Strategies

### 1. Two Pointers Technique

```python
# Example: Remove duplicates from sorted array
def remove_duplicates(nums):
    if not nums:
        return 0

    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]

    return i + 1

# Time Complexity: O(n)
# Space Complexity: O(1)
```

### 2. Sliding Window Technique

```python
# Example: Maximum sum of subarray of size k
def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None

    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum

    # Slide the window
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)

    return max_sum

# Time Complexity: O(n)
# Space Complexity: O(1)
```

### 3. Binary Search

```python
# Example: Find first bad version
def first_bad_version(n):
    left, right = 1, n

    while left < right:
        mid = left + (right - left) // 2
        if is_bad_version(mid):
            right = mid
        else:
            left = mid + 1

    return left

# Time Complexity: O(log n)
# Space Complexity: O(1)
```

### 4. Dynamic Programming

```python
# Example: Climbing stairs
def climb_stairs(n):
    if n <= 2:
        return n

    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

# Time Complexity: O(n)
# Space Complexity: O(n)
```

### 5. Greedy Approach

```python
# Example: Jump game
def can_jump(nums):
    max_reach = 0

    for i in range(len(nums)):
        if i > max_reach:
            return False

        max_reach = max(max_reach, i + nums[i])

        if max_reach >= len(nums) - 1:
            return True

    return True

# Time Complexity: O(n)
# Space Complexity: O(1)
```

## Practice Problems

### Easy Level

#### Problem 1: Two Sum

```python
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# Test
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # [0, 1]
```

#### Problem 2: Valid Parentheses

```python
def is_valid(s):
    stack = []
    brackets = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in '({[':
            stack.append(char)
        elif char in ')}]':
            if not stack or stack.pop() != brackets[char]:
                return False

    return len(stack) == 0

# Test
print(is_valid("()[]{}"))  # True
print(is_valid("([)]"))    # False
```

### Medium Level

#### Problem 3: Longest Substring Without Repeating Characters

```python
def length_of_longest_substring(s):
    char_map = {}
    left = 0
    max_length = 0

    for right, char in enumerate(s):
        if char in char_map and char_map[char] >= left:
            left = char_map[char] + 1
        char_map[char] = right
        max_length = max(max_length, right - left + 1)

    return max_length

# Test
print(length_of_longest_substring("abcabcbb"))  # 3
print(length_of_longest_substring("bbbbb"))     # 1
```

#### Problem 4: Container With Most Water

```python
def max_area(height):
    left, right = 0, len(height) - 1
    max_area = 0

    while left < right:
        width = right - left
        h = min(height[left], height[right])
        area = width * h
        max_area = max(max_area, area)

        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_area

# Test
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
print(max_area(height))  # 49
```

### Hard Level

#### Problem 5: Median of Two Sorted Arrays

```python
def find_median_sorted_arrays(nums1, nums2):
    # Ensure nums1 is the smaller array
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    x, y = len(nums1), len(nums2)
    low, high = 0, x

    while low <= high:
        partitionX = (low + high) // 2
        partitionY = (x + y + 1) // 2 - partitionX

        maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
        minRightX = float('inf') if partitionX == x else nums1[partitionX]

        maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
        minRightY = float('inf') if partitionY == y else nums2[partitionY]

        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            if (x + y) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            high = partitionX - 1
        else:
            low = partitionX + 1

# Test
nums1 = [1, 3]
nums2 = [2]
print(find_median_sorted_arrays(nums1, nums2))  # 2.0
```

## Tips and Best Practices

### 1. Read the Problem Carefully

- Understand the input format
- Identify edge cases
- Note any constraints
- Clarify requirements

### 2. Start with Simple Examples

```python
# Always test with simple cases first
def example_function():
    # Test case 1: Empty input
    # Test case 2: Single element
    # Test case 3: Two elements
    # Test case 4: Normal case
    pass
```

### 3. Use Meaningful Variable Names

```python
# Good
def find_maximum_subarray_sum(array):
    current_sum = 0
    maximum_sum = float('-inf')

    for number in array:
        current_sum = max(number, current_sum + number)
        maximum_sum = max(maximum_sum, current_sum)

    return maximum_sum

# Bad
def f(a):
    c = 0
    m = float('-inf')
    for n in a:
        c = max(n, c + n)
        m = max(m, c)
    return m
```

### 4. Add Comments for Complex Logic

```python
def complex_algorithm(data):
    # Step 1: Sort the data for efficient processing
    sorted_data = sorted(data)

    # Step 2: Use two pointers to find pairs
    left, right = 0, len(sorted_data) - 1
    result = []

    while left < right:
        current_sum = sorted_data[left] + sorted_data[right]

        # If sum is too small, move left pointer
        if current_sum < target:
            left += 1
        # If sum is too large, move right pointer
        elif current_sum > target:
            right -= 1
        # Found a pair
        else:
            result.append([sorted_data[left], sorted_data[right]])
            left += 1
            right -= 1

    return result
```

### 5. Consider Time and Space Complexity

```python
# Always think about efficiency
def efficient_solution(data):
    # Time: O(n log n) - sorting
    # Space: O(1) - in-place operations
    data.sort()

    # Time: O(n) - single pass
    # Space: O(1) - constant extra space
    for i in range(len(data)):
        # Process each element
        pass

    return result
```

### 6. Handle Edge Cases

```python
def robust_solution(data):
    # Handle empty input
    if not data:
        return []

    # Handle single element
    if len(data) == 1:
        return data

    # Handle negative numbers
    if all(x < 0 for x in data):
        return max(data)

    # Normal processing
    return process_data(data)
```

## Common Mistakes to Avoid

1. **Not reading the problem carefully** - Always understand requirements first
2. **Ignoring edge cases** - Test with empty arrays, single elements, etc.
3. **Not considering time complexity** - Think about efficiency from the start
4. **Overcomplicating solutions** - Start simple, optimize later
5. **Not testing your code** - Always test with multiple cases
6. **Poor variable naming** - Use descriptive names
7. **Not handling errors** - Consider what happens with invalid input

## Resources for Practice

### Online Platforms

- [LeetCode](https://leetcode.com)
- [HackerRank](https://hackerrank.com)
- [Codeforces](https://codeforces.com)
- [AtCoder](https://atcoder.jp)

### Problem Categories

- **Arrays & Strings**: Two pointers, sliding window
- **Trees & Graphs**: DFS, BFS, traversal
- **Dynamic Programming**: Memoization, tabulation
- **Greedy**: Local optimal choices
- **Binary Search**: Sorted arrays, optimization

## Next Steps

Now that you understand problem-solving strategies:

1. Practice regularly on coding platforms
2. Review [Interview Questions](/interview-prep)
3. Build [Projects](/projects) to apply your skills
4. Join coding communities and participate in contests

---

**Remember**: Problem-solving is a skill that improves with practice. Solve problems daily and learn from each solution!
